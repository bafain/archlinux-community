From 426644f6d085e053fa0fcf3457702eac685b7cba Mon Sep 17 00:00:00 2001
From: Antonio Rojas <arojas@archlinux.org>
Date: Sat, 7 Jul 2018 00:37:37 +0200
Subject: Adapt to singular 4.1.1 API changes

---
 src/sage/libs/singular/decl.pxd                          |  4 ++--
 .../rings/polynomial/multi_polynomial_libsingular.pyx    | 16 ++++++++--------
 src/sage/rings/polynomial/plural.pyx                     |  4 ++--
 3 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/src/sage/libs/singular/decl.pxd b/src/sage/libs/singular/decl.pxd
index 4b658c4..84476a9 100644
--- a/src/sage/libs/singular/decl.pxd
+++ b/src/sage/libs/singular/decl.pxd
@@ -170,7 +170,7 @@ cdef extern from "singular/Singular/libsingular.h":
 
     int n_NumberOfParameters(const n_Procs_s* r)
 
-    ctypedef struct poly "polyrec":
+    ctypedef struct poly "spolyrec":
         poly *next
         number *coef
         unsigned long exp[1]
@@ -632,7 +632,7 @@ cdef extern from "singular/Singular/libsingular.h":
 
     # divide monomial p by monomial q, p,q const
 
-    poly *pDivide(poly *p,poly *q)
+    poly *pMDivide(poly *p,poly *q)
 
     # return the i-th power of p; p destroyed, requires global ring
 
diff --git a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
index 2a8d9ae..f2a11a8 100644
--- a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
+++ b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
@@ -190,8 +190,8 @@ from sage.libs.singular.decl cimport (
     n_IsUnit, n_Invers,
     p_ISet, rChangeCurrRing, p_Copy, p_Init, p_SetCoeff, p_Setm, p_SetExp, p_Add_q,
     p_NSet, p_GetCoeff, p_Delete, p_GetExp, pNext, rRingVar, omAlloc0, omStrDup,
-    omFree, pDivide, p_SetCoeff0, n_Init, p_DivisibleBy, pLcm, p_LmDivisibleBy,
-    pDivide, p_IsConstant, p_ExpVectorEqual, p_String, p_LmInit, n_Copy,
+    omFree, pMDivide, p_SetCoeff0, n_Init, p_DivisibleBy, pLcm, p_LmDivisibleBy,
+    pMDivide, p_IsConstant, p_ExpVectorEqual, p_String, p_LmInit, n_Copy,
     p_IsUnit, p_Series, p_Head, idInit, fast_map_common_subexp, id_Delete,
     p_IsHomogeneous, p_Homogen, p_Totaldegree,pLDeg1_Totaldegree, singclap_pdivide, singclap_factorize,
     idLift, IDELEMS, On, Off, SW_USE_CHINREM_GCD, SW_USE_EZGCD,
@@ -1693,8 +1693,8 @@ cdef class MPolynomialRing_libsingular(MPolynomialRing_base):
         if not g._poly:
             raise ZeroDivisionError
 
-        if r!=currRing: rChangeCurrRing(r)  # pDivide
-        res = pDivide(f._poly, g._poly)
+        if r!=currRing: rChangeCurrRing(r)  # pMDivide
+        res = pMDivide(f._poly, g._poly)
         if coeff:
             if r.cf.type == n_unknown or r.cf.cfDivBy(p_GetCoeff(f._poly, r), p_GetCoeff(g._poly, r), r.cf):
                 n = r.cf.cfDiv( p_GetCoeff(f._poly, r) , p_GetCoeff(g._poly, r), r.cf)
@@ -1853,8 +1853,8 @@ cdef class MPolynomialRing_libsingular(MPolynomialRing_base):
                    and (<MPolynomial_libsingular>g) \
                    and g.parent() is self \
                    and p_LmDivisibleBy((<MPolynomial_libsingular>g)._poly, m, r):
-                if r!=currRing: rChangeCurrRing(r)  # pDivide
-                flt = pDivide(f._poly, (<MPolynomial_libsingular>g)._poly)
+                if r!=currRing: rChangeCurrRing(r)  # pMDivide
+                flt = pMDivide(f._poly, (<MPolynomial_libsingular>g)._poly)
                 #p_SetCoeff(flt, n_Div( p_GetCoeff(f._poly, r) , p_GetCoeff((<MPolynomial_libsingular>g)._poly, r), r), r)
                 p_SetCoeff(flt, n_Init(1, r), r)
                 return new_MP(self,flt), g
@@ -4055,10 +4055,10 @@ cdef class MPolynomial_libsingular(MPolynomial):
             if _right.is_monomial():
                 p = _self._poly
                 quo = p_ISet(0,r)
-                if r != currRing: rChangeCurrRing(r)   # pDivide
+                if r != currRing: rChangeCurrRing(r)   # pMDivide
                 while p:
                     if p_DivisibleBy(_right._poly, p, r):
-                        temp = pDivide(p, _right._poly)
+                        temp = pMDivide(p, _right._poly)
                         p_SetCoeff0(temp, n_Copy(p_GetCoeff(p, r), r), r)
                         quo = p_Add_q(quo, temp, r)
                     p = pNext(p)
diff --git a/src/sage/rings/polynomial/plural.pyx b/src/sage/rings/polynomial/plural.pyx
index d5439f7f..ad20ebc 100644
--- a/src/sage/rings/polynomial/plural.pyx
+++ b/src/sage/rings/polynomial/plural.pyx
@@ -998,7 +998,7 @@ cdef class NCPolynomialRing_plural(Ring):
         if not g._poly:
             raise ZeroDivisionError
 
-        res = pDivide(f._poly,g._poly)
+        res = pMDivide(f._poly,g._poly)
         if coeff:
             if (r.cf.type == n_unknown) or r.cf.cfDivBy(p_GetCoeff(f._poly, r), p_GetCoeff(g._poly, r), r.cf):
                 n = r.cf.cfDiv( p_GetCoeff(f._poly, r) , p_GetCoeff(g._poly, r), r.cf)
@@ -1193,7 +1193,7 @@ cdef class NCPolynomialRing_plural(Ring):
             if isinstance(g, NCPolynomial_plural) \
                    and (<NCPolynomial_plural>g) \
                    and p_LmDivisibleBy((<NCPolynomial_plural>g)._poly, m, r):
-                flt = pDivide(f._poly, (<NCPolynomial_plural>g)._poly)
+                flt = pMDivide(f._poly, (<NCPolynomial_plural>g)._poly)
                 #p_SetCoeff(flt, n_Div( p_GetCoeff(f._poly, r) , p_GetCoeff((<NCPolynomial_plural>g)._poly, r), r), r)
                 p_SetCoeff(flt, n_Init(1, r), r)
                 return new_NCP(self,flt), g
-- 
cgit v1.0-1-gd88e


From d5fc2a4bc640856507d743c2f67ad454874700e7 Mon Sep 17 00:00:00 2001
From: Antonio Rojas <arojas@archlinux.org>
Date: Sat, 7 Jul 2018 00:38:56 +0200
Subject: Don't call singclap_pdivide for integer coefficients, it's no longer
 supported

---
 src/sage/rings/polynomial/multi_polynomial_libsingular.pyx | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
index f2a11a8..774fecd 100644
--- a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
+++ b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
@@ -4888,7 +4888,7 @@ cdef class MPolynomial_libsingular(MPolynomial):
         if right.is_zero():
             raise ZeroDivisionError
 
-        if not self._parent._base.is_field() and not is_IntegerRing(self._parent._base):
+        if not self._parent._base.is_field():
             py_quo = self//right
             py_rem = self - right*py_quo
             return py_quo, py_rem
-- 
cgit v1.0-1-gd88e


From 4763da19a9ea0be849ee3640fc39747d725cb5a1 Mon Sep 17 00:00:00 2001
From: Antonio Rojas <arojas@archlinux.org>
Date: Sat, 21 Jul 2018 11:31:02 +0200
Subject: Fix lcm of polynomials with integer coefficients and add test

---
 src/sage/rings/polynomial/multi_polynomial_libsingular.pyx | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
index 774fecd..bb5aca6 100644
--- a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
+++ b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
@@ -4794,6 +4794,8 @@ cdef class MPolynomial_libsingular(MPolynomial):
             sage: p = -x*y + x*z + 54*x - 2
             sage: (5*p^2).lcm(3*p) == 15*p^2
             True
+            sage: lcm(2*x,2*x*y)
+            2*x*y
         """
         cdef ring *_ring = self._parent_ring
         cdef poly *ret
@@ -4805,6 +4807,12 @@ cdef class MPolynomial_libsingular(MPolynomial):
         if _ring.cf.type != n_unknown:
             if _ring.cf.type == n_Znm or _ring.cf.type == n_Zn or _ring.cf.type == n_Z2m :
                 raise TypeError("LCM over non-integral domains not available.")
+            if _ring.cf.type == n_Z:
+                f_content = self.content()
+                g_content = g.content()
+                f_primitivepart = self / f_content
+                g_primitivepart = g / g_content
+                return f_primitivepart.change_ring(RationalField()).lcm(g_primitivepart.change_ring(RationalField())) * f_content.lcm(g_content)
 
         if self._parent is not g._parent:
             _g = self._parent._coerce_c(g)
-- 
cgit v1.0-1-gd88e


From 544f67d45ce00142d99cbca7ca1ef39df95d3551 Mon Sep 17 00:00:00 2001
From: Timo Kaufmann <timokau@zoho.com>
Date: Fri, 20 Jul 2018 16:58:48 +0200
Subject: =?UTF-8?q?Revert=20"Trac=20#25313:=20Speed=20up=20exact=20divisio?=
 =?UTF-8?q?n=20in=20=E2=84=A4[x,y,...]"?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This reverts commit 5ef19ad3901910976878348ef2ec76637420010b, reversing
changes made to 1c41c1d6cadf5bb863d5c0d125300a153f232fa5.
---
 .../rings/polynomial/multi_polynomial_libsingular.pyx     | 15 +++++----------
 1 file changed, 5 insertions(+), 10 deletions(-)

diff --git a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
index bb5aca6..92d6ed5 100644
--- a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
+++ b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
@@ -4023,16 +4023,6 @@ cdef class MPolynomial_libsingular(MPolynomial):
             Traceback (most recent call last):
             ...
             NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.
-
-        TESTS::
-
-            sage: P.<x,y> = ZZ[]
-            sage: p = 3*(-x^8*y^2 - x*y^9 + 6*x^8*y + 17*x^2*y^6 - x^3*y^2)
-            sage: q = 7*(x^2 + x*y + y^2 + 1)
-            sage: p*q//q == p
-            True
-            sage: p*q//p == q
-            True
         """
         cdef MPolynomialRing_libsingular parent = self._parent
         cdef ring *r = self._parent_ring
@@ -4052,6 +4042,11 @@ cdef class MPolynomial_libsingular(MPolynomial):
         _right = <MPolynomial_libsingular>right
 
         if r.cf.type != n_unknown:
+            if r.cf.type == n_Z:
+                P = parent.change_ring(RationalField())
+                f = P(self)//P(right)
+                CM = list(f)
+                return parent(sum([c.floor()*m for c,m in CM]))
             if _right.is_monomial():
                 p = _self._poly
                 quo = p_ISet(0,r)
-- 
cgit v1.0-1-gd88e


From 2cd8487ff5a7f74c6c75659b44be5f48d27639e6 Mon Sep 17 00:00:00 2001
From: Timo Kaufmann <timokau@zoho.com>
Date: Fri, 20 Jul 2018 18:32:20 +0200
Subject: singular: update doctests

---
 src/sage/rings/polynomial/multi_polynomial_ideal.py        | 1 +
 src/sage/rings/polynomial/multi_polynomial_libsingular.pyx | 2 +-
 src/sage/rings/polynomial/polynomial_singular_interface.py | 8 ++++----
 3 files changed, 6 insertions(+), 5 deletions(-)

diff --git a/src/sage/rings/polynomial/multi_polynomial_ideal.py b/src/sage/rings/polynomial/multi_polynomial_ideal.py
index 37dc45c..8bd5306 100644
--- a/src/sage/rings/polynomial/multi_polynomial_ideal.py
+++ b/src/sage/rings/polynomial/multi_polynomial_ideal.py
@@ -2199,6 +2199,7 @@ class MPolynomialIdeal_singular_repr(
             sage: I.variety()
             verbose 0 (...: multi_polynomial_ideal.py, variety) Warning: computations in the complex field are inexact; variety may be computed partially or incorrectly.
             verbose 0 (...: multi_polynomial_ideal.py, variety) Warning: falling back to very slow toy implementation.
+            ...
             [{y: -0.86602540378443... - 0.500000000000000*I},
              {y: -0.86602540378443... + 0.500000000000000*I},
              {y: 0.86602540378443... - 0.500000000000000*I},
diff --git a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
index 92d6ed5..619e7f0 100644
--- a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
+++ b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
@@ -4869,7 +4869,7 @@ cdef class MPolynomial_libsingular(MPolynomial):
             sage: f.quo_rem(y)
             (2*x^2, x + 1)
             sage: f.quo_rem(3*x)
-            (2*x*y + 1, -4*x^2*y - 2*x + 1)
+            (0, 2*x^2*y + x + 1)
 
         TESTS::
 
diff --git a/src/sage/rings/polynomial/polynomial_singular_interface.py b/src/sage/rings/polynomial/polynomial_singular_interface.py
index 9331169..f753610 100644
--- a/src/sage/rings/polynomial/polynomial_singular_interface.py
+++ b/src/sage/rings/polynomial/polynomial_singular_interface.py
@@ -81,8 +81,8 @@ class PolynomialRing_singular_repr:
             sage: R.<x,y> = PolynomialRing(CC)
             sage: singular(R)
             polynomial ring, over a field, global ordering
-            //   coefficients: float[I](complex:15 digits, additional 0 digits)/(I^2+1)
-            //   number of vars : 2
+            // coefficients: real[I](complex:15 digits, additional 0 digits)/(I^2+1)
+            // number of vars : 2
             //        block   1 : ordering dp
             //                  : names    x y
             //        block   2 : ordering C
@@ -90,8 +90,8 @@ class PolynomialRing_singular_repr:
             sage: R.<x,y> = PolynomialRing(RealField(100))
             sage: singular(R)
             polynomial ring, over a field, global ordering
-            //   coefficients: float
-            //   number of vars : 2
+            // coefficients: Float()
+            // number of vars : 2
             //        block   1 : ordering dp
             //                  : names    x y
             //        block   2 : ordering C
-- 
cgit v1.0-1-gd88e


From d9dc104b4ff3d3cc34fa8ec9483f83fce033f627 Mon Sep 17 00:00:00 2001
From: Antonio Rojas <arojas@archlinux.org>
Date: Sun, 22 Jul 2018 00:54:38 +0200
Subject: Make Singular error parser more granular

---
 src/sage/interfaces/singular.py                     | 2 +-
 src/sage/rings/polynomial/multi_polynomial_ideal.py | 1 -
 2 files changed, 1 insertion(+), 2 deletions(-)

diff --git a/src/sage/interfaces/singular.py b/src/sage/interfaces/singular.py
index 9d65c9f..031172e 100644
--- a/src/sage/interfaces/singular.py
+++ b/src/sage/interfaces/singular.py
@@ -654,7 +654,7 @@ class Singular(ExtraTabCompletion, Expect):
 
         s = Expect.eval(self, x, **kwds)
 
-        if s.find("error") != -1 or s.find("Segment fault") != -1:
+        if s.find("error occurred") != -1 or s.find("Segment fault") != -1:
             raise SingularError('Singular error:\n%s'%s)
 
         if get_verbose() > 0:
diff --git a/src/sage/rings/polynomial/multi_polynomial_ideal.py b/src/sage/rings/polynomial/multi_polynomial_ideal.py
index 8bd5306..37dc45c 100644
--- a/src/sage/rings/polynomial/multi_polynomial_ideal.py
+++ b/src/sage/rings/polynomial/multi_polynomial_ideal.py
@@ -2199,7 +2199,6 @@ class MPolynomialIdeal_singular_repr(
             sage: I.variety()
             verbose 0 (...: multi_polynomial_ideal.py, variety) Warning: computations in the complex field are inexact; variety may be computed partially or incorrectly.
             verbose 0 (...: multi_polynomial_ideal.py, variety) Warning: falling back to very slow toy implementation.
-            ...
             [{y: -0.86602540378443... - 0.500000000000000*I},
              {y: -0.86602540378443... + 0.500000000000000*I},
              {y: 0.86602540378443... - 0.500000000000000*I},
-- 
cgit v1.0-1-gd88e


From ab851b1a2485c98b9f281e5bb5ea294e84f39040 Mon Sep 17 00:00:00 2001
From: Antonio Rojas <arojas@archlinux.org>
Date: Sun, 22 Jul 2018 01:02:23 +0200
Subject: Update some tests output

---
 src/sage/interfaces/singular.py | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/sage/interfaces/singular.py b/src/sage/interfaces/singular.py
index 031172e..f7972f5 100644
--- a/src/sage/interfaces/singular.py
+++ b/src/sage/interfaces/singular.py
@@ -1079,7 +1079,7 @@ class Singular(ExtraTabCompletion, Expect):
             sage: S = singular.ring('real', '(a,b)', 'lp')
             sage: singular.current_ring()
             polynomial ring, over a field, global ordering
-            //   coefficients: float
+            //   coefficients: Float()
             //   number of vars : 2
             //        block   1 : ordering lp
             //                  : names    a b
@@ -1157,7 +1157,7 @@ class Singular(ExtraTabCompletion, Expect):
              sage: singular._tab_completion()
              ['exteriorPower',
               ...
-              'flintZ']
+              'crossprod']
          """
         p = re.compile("// *([a-z0-9A-Z_]*).*") #compiles regular expression
         proclist = self.eval("listvar(proc)").splitlines()
@@ -1183,7 +1183,7 @@ class Singular(ExtraTabCompletion, Expect):
         EXAMPLES::
 
             sage: singular.version()
-            "Singular ... version 4.1.0 ...
+            "Singular ... version 4.1.1 ...
         """
         return singular_version()
 
@@ -1992,7 +1992,7 @@ class SingularElement(ExtraTabCompletion, ExpectElement):
             sage: S = singular.ring('real', '(a,b)', 'lp')
             sage: singular.current_ring()
             polynomial ring, over a field, global ordering
-            //   coefficients: float
+            //   coefficients: Float()
             //   number of vars : 2
             //        block   1 : ordering lp
             //                  : names    a b
@@ -2072,7 +2072,7 @@ class SingularElement(ExtraTabCompletion, ExpectElement):
             sage: R._tab_completion()
             ['exteriorPower',
              ...
-             'flintZ']
+             'crossprod']
         """
         return self.parent()._tab_completion()
 
@@ -2358,7 +2358,7 @@ def singular_version():
     EXAMPLES::
 
         sage: singular.version()
-        "Singular ... version 4.1.0 ...
+        "Singular ... version 4.1.1 ...
     """
     return singular.eval('system("--version");')
 
-- 
cgit v1.0-1-gd88e


From 921cc310908e1880884af556dc9452c2b4ba8bc8 Mon Sep 17 00:00:00 2001
From: Antonio Rojas <arojas@archlinux.org>
Date: Tue, 24 Jul 2018 18:45:26 +0200
Subject: Fix real base ring detection

Singular prints it as 'Float()' instead of 'real' now
---
 src/sage/interfaces/singular.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/sage/interfaces/singular.py b/src/sage/interfaces/singular.py
index f7972f5..3815951 100644
--- a/src/sage/interfaces/singular.py
+++ b/src/sage/interfaces/singular.py
@@ -1562,7 +1562,7 @@ class SingularElement(ExtraTabCompletion, ExpectElement):
         elif charstr[0] in ['0', 'QQ']:
             from sage.all import QQ
             br = QQ
-        elif charstr[0]=='real':
+        elif charstr[0].startswith('Float'):
             from sage.all import RealField, ceil, log
             prec = singular.eval('ringlist(basering)[1][2][1]')
             br = RealField(ceil((ZZ(prec)+1)/log(2,10)))
-- 
cgit v1.0-1-gd88e


From 0f55b763c775bb0d652b53d50dc26f11e9f472a0 Mon Sep 17 00:00:00 2001
From: Antonio Rojas <arojas@archlinux.org>
Date: Tue, 24 Jul 2018 19:16:20 +0200
Subject: More real -> Float porting

---
 src/sage/interfaces/singular.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/sage/interfaces/singular.py b/src/sage/interfaces/singular.py
index 3815951..0447920 100644
--- a/src/sage/interfaces/singular.py
+++ b/src/sage/interfaces/singular.py
@@ -1750,7 +1750,7 @@ class SingularElement(ExtraTabCompletion, ExpectElement):
 
         # Singular 4 puts parentheses around floats and sign outside them
         charstr = self.parent().eval('charstr(basering)').split(',',1)
-        if charstr[0] in ['real', 'complex']:
+        if charstr[0]=='complex' or charstr[0].startswith('Float'):
               for i in range(coeff_start, 2 * coeff_start):
                   singular_poly_list[i] = singular_poly_list[i].replace('(','').replace(')','')
 
-- 
cgit v1.0-1-gd88e


From aea054407a41a517070eb06e8efcd02d6356269f Mon Sep 17 00:00:00 2001
From: Antonio Rojas <arojas@archlinux.org>
Date: Tue, 24 Jul 2018 19:38:55 +0200
Subject: Don't check for exact Singular version

Should improve testing future Singular upgrades on distributions
---
 src/sage/interfaces/singular.py | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/sage/interfaces/singular.py b/src/sage/interfaces/singular.py
index 0447920..a028bbe 100644
--- a/src/sage/interfaces/singular.py
+++ b/src/sage/interfaces/singular.py
@@ -1183,7 +1183,7 @@ class Singular(ExtraTabCompletion, Expect):
         EXAMPLES::
 
             sage: singular.version()
-            "Singular ... version 4.1.1 ...
+            "Singular ... version 4...
         """
         return singular_version()
 
@@ -2358,7 +2358,7 @@ def singular_version():
     EXAMPLES::
 
         sage: singular.version()
-        "Singular ... version 4.1.1 ...
+        "Singular ... version 4...
     """
     return singular.eval('system("--version");')
 
-- 
cgit v1.0-1-gd88e


From 4e52b5e3ca6bbb34666c25decbf9bab3e2b46e82 Mon Sep 17 00:00:00 2001
From: Antonio Rojas <arojas@archlinux.org>
Date: Wed, 25 Jul 2018 16:17:38 +0200
Subject: Use p_Divide for lcm as suggested by upstream

See https://www.singular.uni-kl.de/forum/viewtopic.php?f=10&t=2768
---
 src/sage/libs/singular/decl.pxd                            |  4 ++++
 src/sage/rings/polynomial/multi_polynomial_libsingular.pyx | 12 ++----------
 2 files changed, 6 insertions(+), 10 deletions(-)

diff --git a/src/sage/libs/singular/decl.pxd b/src/sage/libs/singular/decl.pxd
index 84476a9..d863740 100644
--- a/src/sage/libs/singular/decl.pxd
+++ b/src/sage/libs/singular/decl.pxd
@@ -630,6 +630,10 @@ cdef extern from "singular/Singular/libsingular.h":
     # return p*q, destroys p and q
     poly *p_Mult_q(poly *p, poly *q, ring *r)
 
+    # polynomial division, ignoring the rest
+    # via singclap_pdivide resp. idLift, destroys p,q
+    poly *p_Divide(poly *p, poly *q, ring *r)
+
     # divide monomial p by monomial q, p,q const
 
     poly *pMDivide(poly *p,poly *q)
diff --git a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
index 619e7f0..aeff53a 100644
--- a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
+++ b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
@@ -190,7 +190,7 @@ from sage.libs.singular.decl cimport (
     n_IsUnit, n_Invers,
     p_ISet, rChangeCurrRing, p_Copy, p_Init, p_SetCoeff, p_Setm, p_SetExp, p_Add_q,
     p_NSet, p_GetCoeff, p_Delete, p_GetExp, pNext, rRingVar, omAlloc0, omStrDup,
-    omFree, pMDivide, p_SetCoeff0, n_Init, p_DivisibleBy, pLcm, p_LmDivisibleBy,
+    omFree, pMDivide, p_Divide, p_SetCoeff0, n_Init, p_DivisibleBy, pLcm, p_LmDivisibleBy,
     pMDivide, p_IsConstant, p_ExpVectorEqual, p_String, p_LmInit, n_Copy,
     p_IsUnit, p_Series, p_Head, idInit, fast_map_common_subexp, id_Delete,
     p_IsHomogeneous, p_Homogen, p_Totaldegree,pLDeg1_Totaldegree, singclap_pdivide, singclap_factorize,
@@ -4802,12 +4802,6 @@ cdef class MPolynomial_libsingular(MPolynomial):
         if _ring.cf.type != n_unknown:
             if _ring.cf.type == n_Znm or _ring.cf.type == n_Zn or _ring.cf.type == n_Z2m :
                 raise TypeError("LCM over non-integral domains not available.")
-            if _ring.cf.type == n_Z:
-                f_content = self.content()
-                g_content = g.content()
-                f_primitivepart = self / f_content
-                g_primitivepart = g / g_content
-                return f_primitivepart.change_ring(RationalField()).lcm(g_primitivepart.change_ring(RationalField())) * f_content.lcm(g_content)
 
         if self._parent is not g._parent:
             _g = self._parent._coerce_c(g)
@@ -4824,9 +4818,7 @@ cdef class MPolynomial_libsingular(MPolynomial):
         if _ring!=currRing: rChangeCurrRing(_ring)  # singclap_gcd
         gcd = singclap_gcd(p_Copy(self._poly, _ring), p_Copy(_g._poly, _ring), _ring )
         prod = pp_Mult_qq(self._poly, _g._poly, _ring)
-        ret = singclap_pdivide(prod , gcd , _ring)
-        p_Delete(&prod, _ring)
-        p_Delete(&gcd, _ring)
+        ret = p_Divide(prod, gcd, _ring)
         if count >= 20:
             sig_off()
         return new_MP(self._parent, ret)
-- 
cgit v1.0-1-gd88e

From 930ba2eb1cacaf4e1e43733feb560dd105d531be Mon Sep 17 00:00:00 2001
From: Antonio Rojas <arojas@archlinux.org>
Date: Wed, 25 Jul 2018 22:45:15 +0200
Subject: Remove duplicate cimport

---
 src/sage/rings/polynomial/multi_polynomial_libsingular.pyx | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
index aeff53a..f0a174f 100644
--- a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
+++ b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
@@ -190,7 +190,7 @@ from sage.libs.singular.decl cimport (
     n_IsUnit, n_Invers,
     p_ISet, rChangeCurrRing, p_Copy, p_Init, p_SetCoeff, p_Setm, p_SetExp, p_Add_q,
     p_NSet, p_GetCoeff, p_Delete, p_GetExp, pNext, rRingVar, omAlloc0, omStrDup,
-    omFree, pMDivide, p_Divide, p_SetCoeff0, n_Init, p_DivisibleBy, pLcm, p_LmDivisibleBy,
+    omFree, p_Divide, p_SetCoeff0, n_Init, p_DivisibleBy, pLcm, p_LmDivisibleBy,
     pMDivide, p_IsConstant, p_ExpVectorEqual, p_String, p_LmInit, n_Copy,
     p_IsUnit, p_Series, p_Head, idInit, fast_map_common_subexp, id_Delete,
     p_IsHomogeneous, p_Homogen, p_Totaldegree,pLDeg1_Totaldegree, singclap_pdivide, singclap_factorize,
-- 
cgit v1.0-1-gd88e

From 07ef11b3209f498dc771bf5cb02f1b3ce1264cbb Mon Sep 17 00:00:00 2001
From: Antonio Rojas <arojas@archlinux.org>
Date: Thu, 26 Jul 2018 15:25:57 +0200
Subject: rest -> reminder

---
 src/sage/libs/singular/decl.pxd | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/sage/libs/singular/decl.pxd b/src/sage/libs/singular/decl.pxd
index d863740..7f09aaf 100644
--- a/src/sage/libs/singular/decl.pxd
+++ b/src/sage/libs/singular/decl.pxd
@@ -630,7 +630,7 @@ cdef extern from "singular/Singular/libsingular.h":
     # return p*q, destroys p and q
     poly *p_Mult_q(poly *p, poly *q, ring *r)
 
-    # polynomial division, ignoring the rest
+    # polynomial division, ignoring the remainder
     # via singclap_pdivide resp. idLift, destroys p,q
     poly *p_Divide(poly *p, poly *q, ring *r)
 
-- 
cgit v1.0-1-gd88e


From a9e5aed9215175f8cf49327c790ae153648a2513 Mon Sep 17 00:00:00 2001
From: Jeroen Demeyer <jdemeyer@cage.ugent.be>
Date: Sat, 28 Jul 2018 15:09:54 +0200
Subject: Minor fixes to Singular interface

---
 src/sage/interfaces/singular.py                    |  4 +-
 .../polynomial/multi_polynomial_libsingular.pyx    | 79 ++++++++++++----------
 src/sage/rings/polynomial/plural.pyx               | 19 +++---
 3 files changed, 55 insertions(+), 47 deletions(-)

diff --git a/src/sage/interfaces/singular.py b/src/sage/interfaces/singular.py
index a028bbe..3d563ff 100644
--- a/src/sage/interfaces/singular.py
+++ b/src/sage/interfaces/singular.py
@@ -654,6 +654,8 @@ class Singular(ExtraTabCompletion, Expect):
 
         s = Expect.eval(self, x, **kwds)
 
+        # "Segment fault" is not a typo:
+        # Singular actually does use that string
         if s.find("error occurred") != -1 or s.find("Segment fault") != -1:
             raise SingularError('Singular error:\n%s'%s)
 
@@ -1750,7 +1752,7 @@ class SingularElement(ExtraTabCompletion, ExpectElement):
 
         # Singular 4 puts parentheses around floats and sign outside them
         charstr = self.parent().eval('charstr(basering)').split(',',1)
-        if charstr[0]=='complex' or charstr[0].startswith('Float'):
+        if charstr[0].startswith('Float') or charstr[0] == 'complex':
               for i in range(coeff_start, 2 * coeff_start):
                   singular_poly_list[i] = singular_poly_list[i].replace('(','').replace(')','')
 
diff --git a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
index f0a174f..043696e 100644
--- a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
+++ b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
@@ -181,8 +181,8 @@ from cysignals.signals cimport sig_on, sig_off
 from sage.cpython.string cimport char_to_str, str_to_bytes
 
 # singular types
-from sage.libs.singular.decl cimport ring, poly, ideal, intvec, number, currRing
-from sage.libs.singular.decl cimport n_unknown,  n_Zp,  n_Q,   n_R,   n_GF,  n_long_R,  n_algExt,n_transExt,n_long_C,   n_Z,   n_Zn,  n_Znm,  n_Z2m,  n_CF
+from sage.libs.singular.decl cimport (ring, poly, ideal, intvec, number,
+    currRing, n_unknown, n_Z, n_Zn, n_Znm, n_Z2m)
 
 # singular functions
 from sage.libs.singular.decl cimport (
@@ -198,7 +198,7 @@ from sage.libs.singular.decl cimport (
     p_LmIsConstant, pTakeOutComp1, singclap_gcd, pp_Mult_qq, p_GetMaxExp,
     pLength, kNF, p_Neg, p_Minus_mm_Mult_qq, p_Plus_mm_Mult_qq,
     pDiff, singclap_resultant, p_Normalize,
-    prCopyR, prCopyR_NoSort )
+    prCopyR, prCopyR_NoSort)
 
 # singular conversion routines
 from sage.libs.singular.singular cimport si2sa, sa2si, overflow_check
@@ -225,7 +225,7 @@ from sage.rings.polynomial.polynomial_ring import is_PolynomialRing
 # base ring imports
 from sage.rings.finite_rings.finite_field_prime_modn import FiniteField_prime_modn
 from sage.rings.rational cimport Rational
-from sage.rings.rational_field import RationalField
+from sage.rings.rational_field import QQ
 from sage.rings.complex_field import is_ComplexField
 from sage.rings.real_mpfr import is_RealField
 from sage.rings.integer_ring import is_IntegerRing, ZZ
@@ -1693,7 +1693,8 @@ cdef class MPolynomialRing_libsingular(MPolynomialRing_base):
         if not g._poly:
             raise ZeroDivisionError
 
-        if r!=currRing: rChangeCurrRing(r)  # pMDivide
+        if r is not currRing:
+            rChangeCurrRing(r)
         res = pMDivide(f._poly, g._poly)
         if coeff:
             if r.cf.type == n_unknown or r.cf.cfDivBy(p_GetCoeff(f._poly, r), p_GetCoeff(g._poly, r), r.cf):
@@ -1846,19 +1847,18 @@ cdef class MPolynomialRing_libsingular(MPolynomialRing_base):
         cdef poly *flt
 
         if not m:
-            return f,f
+            return (f, f)
 
         for g in G:
-            if isinstance(g, MPolynomial_libsingular) \
-                   and (<MPolynomial_libsingular>g) \
-                   and g.parent() is self \
-                   and p_LmDivisibleBy((<MPolynomial_libsingular>g)._poly, m, r):
-                if r!=currRing: rChangeCurrRing(r)  # pMDivide
-                flt = pMDivide(f._poly, (<MPolynomial_libsingular>g)._poly)
-                #p_SetCoeff(flt, n_Div( p_GetCoeff(f._poly, r) , p_GetCoeff((<MPolynomial_libsingular>g)._poly, r), r), r)
-                p_SetCoeff(flt, n_Init(1, r), r)
-                return new_MP(self,flt), g
-        return self._zero_element,self._zero_element
+            if isinstance(g, MPolynomial_libsingular) and g:
+                h = <MPolynomial_libsingular>g
+                if h._parent is self and p_LmDivisibleBy(h._poly, m, r):
+                    if r is not currRing:
+                        rChangeCurrRing(r)
+                    flt = pMDivide(f._poly, h._poly)
+                    p_SetCoeff(flt, n_Init(1, r), r)
+                    return (new_MP(self, flt), h)
+        return (self._zero_element, self._zero_element)
 
     def monomial_pairwise_prime(self, MPolynomial_libsingular g, MPolynomial_libsingular h):
         """
@@ -4023,11 +4023,19 @@ cdef class MPolynomial_libsingular(MPolynomial):
             Traceback (most recent call last):
             ...
             NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.
+
+        TESTS::
+
+            sage: P.<x,y> = ZZ[]
+            sage: p = 3*(-x^8*y^2 - x*y^9 + 6*x^8*y + 17*x^2*y^6 - x^3*y^2)
+            sage: q = 7*(x^2 + x*y + y^2 + 1)
+            sage: p*q//q == p
+            True
+            sage: p*q//p == q
+            True
         """
         cdef MPolynomialRing_libsingular parent = self._parent
         cdef ring *r = self._parent_ring
-        if(r != currRing): rChangeCurrRing(r)
-        cdef MPolynomial_libsingular _self, _right
         cdef poly *quo
         cdef poly *temp
         cdef poly *p
@@ -4038,19 +4046,19 @@ cdef class MPolynomial_libsingular(MPolynomial):
         if self._parent._base.is_finite() and self._parent._base.characteristic() > 1<<29:
             raise NotImplementedError("Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.")
 
-        _self = <MPolynomial_libsingular>self
         _right = <MPolynomial_libsingular>right
 
+        if r is not currRing:
+            rChangeCurrRing(r)
+
         if r.cf.type != n_unknown:
             if r.cf.type == n_Z:
-                P = parent.change_ring(RationalField())
-                f = P(self)//P(right)
-                CM = list(f)
-                return parent(sum([c.floor()*m for c,m in CM]))
+                P = parent.change_ring(QQ)
+                f = (<MPolynomial_libsingular>P(self))._floordiv_(P(right))
+                return parent(sum([c.floor() * m for c, m in f]))
             if _right.is_monomial():
-                p = _self._poly
+                p = self._poly
                 quo = p_ISet(0,r)
-                if r != currRing: rChangeCurrRing(r)   # pMDivide
                 while p:
                     if p_DivisibleBy(_right._poly, p, r):
                         temp = pMDivide(p, _right._poly)
@@ -4061,16 +4069,13 @@ cdef class MPolynomial_libsingular(MPolynomial):
             if r.cf.type == n_Znm or r.cf.type == n_Zn or r.cf.type == n_Z2m :
                 raise NotImplementedError("Division of multivariate polynomials over non fields by non-monomials not implemented.")
 
-        cdef int count = singular_polynomial_length_bounded(_self._poly,15)
+        count = singular_polynomial_length_bounded(self._poly, 15)
         if count >= 15:  # note that _right._poly must be of shorter length than self._poly for us to care about this call
             sig_on()
-        if r!=currRing: rChangeCurrRing(r)   # singclap_pdivide
-        quo = singclap_pdivide( _self._poly, _right._poly, r )
+        quo = singclap_pdivide(self._poly, _right._poly, r)
         if count >= 15:
             sig_off()
-        f = new_MP(parent, quo)
-
-        return f
+        return new_MP(parent, quo)
 
     def factor(self, proof=True):
         """
@@ -4789,7 +4794,9 @@ cdef class MPolynomial_libsingular(MPolynomial):
             sage: p = -x*y + x*z + 54*x - 2
             sage: (5*p^2).lcm(3*p) == 15*p^2
             True
-            sage: lcm(2*x,2*x*y)
+            sage: lcm(2*x, 2*y)
+            2*x*y
+            sage: lcm(2*x, 2*x*y)
             2*x*y
         """
         cdef ring *_ring = self._parent_ring
@@ -5222,7 +5229,7 @@ cdef class MPolynomial_libsingular(MPolynomial):
         if ambient_ring is not self._parent:
             raise TypeError("the variable is not in the same ring as self")
 
-        if not ambient_ring.has_coerce_map_from(RationalField()):
+        if not ambient_ring.has_coerce_map_from(QQ):
             raise TypeError("the ring must contain the rational numbers")
 
         gens = ambient_ring.gens()
@@ -5325,8 +5332,8 @@ cdef class MPolynomial_libsingular(MPolynomial):
             raise NotImplementedError("Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.")
 
         if is_IntegerRing(self._parent._base):
-            ret = self.change_ring(RationalField()).resultant(other.change_ring(RationalField()),
-                                                              variable.change_ring(RationalField()))
+            ret = self.change_ring(QQ).resultant(other.change_ring(QQ),
+                                                 variable.change_ring(QQ))
             return ret.change_ring(ZZ)
         elif not self._parent._base.is_field():
             raise ValueError("Resultants require base fields or integer base ring.")
@@ -5457,7 +5464,7 @@ cdef class MPolynomial_libsingular(MPolynomial):
             sage: f.numerator().parent() is P
             True
         """
-        if self.base_ring() == RationalField():
+        if self.base_ring() is QQ:
             #This part is for compatibility with the univariate case,
             #where the numerator of a polynomial over RationalField
             #is a polynomial over IntegerRing
diff --git a/src/sage/rings/polynomial/plural.pyx b/src/sage/rings/polynomial/plural.pyx
index ad20ebc..6dfcb47 100644
--- a/src/sage/rings/polynomial/plural.pyx
+++ b/src/sage/rings/polynomial/plural.pyx
@@ -998,7 +998,7 @@ cdef class NCPolynomialRing_plural(Ring):
         if not g._poly:
             raise ZeroDivisionError
 
-        res = pMDivide(f._poly,g._poly)
+        res = pMDivide(f._poly, g._poly)
         if coeff:
             if (r.cf.type == n_unknown) or r.cf.cfDivBy(p_GetCoeff(f._poly, r), p_GetCoeff(g._poly, r), r.cf):
                 n = r.cf.cfDiv( p_GetCoeff(f._poly, r) , p_GetCoeff(g._poly, r), r.cf)
@@ -1187,17 +1187,16 @@ cdef class NCPolynomialRing_plural(Ring):
         cdef poly *flt
 
         if not m:
-            return f,f
+            return (f, f)
 
         for g in G:
-            if isinstance(g, NCPolynomial_plural) \
-                   and (<NCPolynomial_plural>g) \
-                   and p_LmDivisibleBy((<NCPolynomial_plural>g)._poly, m, r):
-                flt = pMDivide(f._poly, (<NCPolynomial_plural>g)._poly)
-                #p_SetCoeff(flt, n_Div( p_GetCoeff(f._poly, r) , p_GetCoeff((<NCPolynomial_plural>g)._poly, r), r), r)
-                p_SetCoeff(flt, n_Init(1, r), r)
-                return new_NCP(self,flt), g
-        return self._zero_element,self._zero_element
+            if isinstance(g, NCPolynomial_plural) and g:
+                h = <NCPolynomial_plural>g
+                if p_LmDivisibleBy(h._poly, m, r):
+                    flt = pMDivide(f._poly, h._poly)
+                    p_SetCoeff(flt, n_Init(1, r), r)
+                    return (new_NCP(self,flt), h)
+        return (self._zero_element, self._zero_element)
 
     def monomial_pairwise_prime(self, NCPolynomial_plural g, NCPolynomial_plural h):
         """
-- 
cgit v1.0-1-gd88e


From 45ff3719d4f9059a0e85d142cd1e31cb87efa11c Mon Sep 17 00:00:00 2001
From: Jeroen Demeyer <jdemeyer@cage.ugent.be>
Date: Wed, 8 Aug 2018 10:31:27 +0200
Subject: Fix debug build of Singular

---
 build/pkgs/singular/spkg-install | 10 ++--------
 1 file changed, 2 insertions(+), 8 deletions(-)

diff --git a/build/pkgs/singular/spkg-install b/build/pkgs/singular/spkg-install
index 41dcad1..5a4d8de 100644
--- a/build/pkgs/singular/spkg-install
+++ b/build/pkgs/singular/spkg-install
@@ -6,16 +6,10 @@ SRC=`pwd`/src
 cd "$SRC"
 
 if [ "x$SAGE_DEBUG" = "xyes" ]; then
+    # This used to disable omalloc but that is not really supported
+    # by upstream
     SINGULAR_CONFIGURE="$SINGULAR_CONFIGURE --enable-debug --disable-optimizationflags"
 
-    # --disable-omalloc is broken: linking fails because of missing flags
-    #SINGULAR_CONFIGURE="$SINGULAR_CONFIGURE --disable-omalloc"
-
-    # Replace omalloc by xalloc in places unaffected by --disable-omalloc
-    # See xalloc/README, altough here we just replace the folder for simplicity
-    rm -rf "$SRC/omalloc"
-    mv "$SRC/xalloc" "$SRC/omalloc"
-
     CFLAGS="$CFLAGS -O0 -g"
     CXXFLAGS="$CXXFLAGS -O0 -g"
 else
-- 
cgit v1.0-1-gd88e

